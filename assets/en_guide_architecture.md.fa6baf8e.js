import{_ as e,j as t,g as o,H as a}from"./chunks/framework.8815fd6f.js";var r="/assets/architecture-en.4a9d65d7.png";const g=JSON.parse('{"title":"Brief analysis of Architecture","description":"","frontmatter":{},"headers":[{"level":2,"title":"Target loading","slug":"target-loading"},{"level":2,"title":"PoC script loading","slug":"poc-script-loading"},{"level":2,"title":"Multithread detection","slug":"multithread-detection"},{"level":2,"title":"Results summary","slug":"results-summary"}],"relativePath":"en/guide/architecture.md","lastUpdated":1658474088000}'),i={name:"en/guide/architecture.md"},s=a('<h1 id="brief-analysis-of-architecture" tabindex="-1">Brief analysis of Architecture <a class="header-anchor" href="#brief-analysis-of-architecture" aria-hidden="true">#</a></h1><p>In order to use it more smoothly, it is necessary to understand the architecture of the framework. On the whole, this framework mainly includes four parts: target loading, PoC script loading, multithread detection and results summary. As shown in the following figure:</p><p><img src="'+r+'" alt=""></p><h2 id="target-loading" tabindex="-1">Target loading <a class="header-anchor" href="#target-loading" aria-hidden="true">#</a></h2><p>First, let&#39;s take a look at target loading. Currently, the following methods are supported:</p><ul><li><code>-u</code> specify a single URL or CIDR, which supports IPv4 / IPv6. Using the <code>-p</code> parameter can provide additional ports, and it is convenient to detect a whole network of adjacent hosts.</li><li><code>-f</code> specify a file (save multiple URL/CIDRs to a file, one per line).</li><li><code>--dork</code>, the framework integrates common cyberspace search engines such as ZoomEye, Shodan and so on. It can automatically import targets by providing search keywords and <code>API-KEY</code> with corresponding parameters. It is worth mentioning that users can also put search keywords into the dork attribute of the PoC script.</li><li><code>--plugins</code> call the plugin to load the target, such as <code>target_from_redis</code>. Users can also customize the <a href="./plugin-targets.html">TARGETS plugin</a>.</li></ul><h2 id="poc-script-loading" tabindex="-1">PoC script loading <a class="header-anchor" href="#poc-script-loading" aria-hidden="true">#</a></h2><ul><li>The <code>-r</code> option supports specifying one or more PoC filepaths (or directories). If a directory is provided, the framework will traverse the directory and then load all qualified PoCs. Users can use the <code>-k</code> option to specify keywords to filter PoCs, such as component name, CVE number, etc. If we confirm the target component, we can use the <code>-k</code> option to find all the corresponding PoCs for batch testing of the target. If only the <code>-k</code> option is provided, <code>-r</code> defaults to the <code>pocsuite3/pocs</code> directory that comes with Pocsuite3.</li><li><code>--plugins</code> call the plugin to load PoC, such as <code>poc_from_seebug</code>\u3001<code>poc_from_redis</code>. Users can also customize <a href="./plugin-pocs.html">POCS plugins</a>.</li></ul><h2 id="multithread-detection" tabindex="-1">Multithread detection <a class="header-anchor" href="#multithread-detection" aria-hidden="true">#</a></h2><p>After the user specifies the target and PoC, the framework will match each target and PoC (Cartesian product), generate a queue with element <code>(target, poc_module)</code>, and then start a thread pool with the default size of 150 (can be set through <code>--threads</code>) to process this queue.</p><p>In Pocsuite3, the PoC script has three running modes, corresponding to the three methods defined in the PoC respectively. The command line parameters <code>--verify</code>, <code>--attack</code>, <code>--shell</code> can be used to determine which method to execute. If not specified, the default is <code>--verify</code>.</p><p>What a thread needs to do is to initialize the PoC script with target as the parameter, execute the specified method, and then obtain the execution result.</p><h2 id="results-summary" tabindex="-1">Results summary <a class="header-anchor" href="#results-summary" aria-hidden="true">#</a></h2><p>After obtaining the execution results in the previous step, the framework provides a variety of methods to process and save the results.</p><ul><li>Console log, <code>-v</code> parameter controls the log level, <code>--ppt</code> parameter can hide ip address, which is convenient for screen recording.</li><li><code>-o</code> parameter saves the result as a file in JSON Lines format.</li><li><code>--plugins</code> calls the plugin to process the results, such as <code>file_record</code>\uFF0C<code>html_report</code>. Users can also customize the <a href="./plugin-results.html">RESULTS plugin</a>.</li></ul>',15),c=[s];function d(n,l,h,u,p,m){return o(),t("div",null,c)}var _=e(i,[["render",d]]);export{g as __pageData,_ as default};
